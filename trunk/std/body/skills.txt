// Last edited by deforce on 03-11-2010
#include <classes.h>
#include <hooks.h>

int get_stat_bonus(string skill);
int get_stat_weight(string skill);
int query_skill_evaluation();
int query_int();
int get_skill_point_minimum(int adv_rate);
mixed call_hooks(string, int);

private mapping skills = ([ ]);
private string array learned_skills = ({ });
private string array blocked_skills = ({ });

int set_skill(string skill, int skill_points, int training_points)
{
   if (member_array(skill, SKILL_D->query_skills()) == -1)
   {
      error("Illegal skill; cannot set new skill value for " + skill + " for " + this_object()->short() + ".\n");
   }

/*
   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set " + this_object()->short() + "'s skill in " + skill + " to " + skill_points + ".\n");
   }
*/

   if (skill_points < 1)
   {
      map_delete(skills, skill);
   }
   else
   {
      skills[skill] = ({ skill_points, training_points });
   }

   return 1;
}

void remove_skill(string skill)
{
/*
   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to remove " + this_object()->short() + "'s skill in " + skill + ".\n");
   }
*/

   if (skills[skill])
   {
      map_delete(skills, skill);
   }
}

void reset_skills()
{
/*
   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to reset " + this_object()->short() + "'s skills.\n");
   }
*/

   skills = ([ ]);
}

mapping get_skills()
{
   return skills;
}

int array get_skill(string skill)
{
   return skills[skill];
}

int array query_skill(string skill)
{
   if (skills[skill] && (sizeof(skills[skill]) == 2))
   {
      return skills[skill][0];
   }

   return 0;
}

//:FUNCTION learn_skill
// Add some number of skill points to the given skill, propogating skill
// values up through the parent skills.  Training points are also assigned as appropriate.
void learn_skill(string skill, int value)
{
   int array my_skill;
   int skill_value;
   int advrate;
   mixed skill_data;
   int roll;
   float chance;

/*
   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to use learn_skill on  " + this_object()->short() + ".\n");
   }
*/

   skill_data = SKILL_D->query_skill(skill);

   if (!skill_data)
   {
      error("No skill data for " + skill + ".\n");
   }

   my_skill = skills[skill];

   if (sizeof(my_skill) != 2)
   {
      my_skill = ({ 0, 0 });
   }

   skill_value = my_skill[0];

   if (skill_value < 1000)
   {
      advrate = skill_data[1];

      roll = random(skill_value * 10);
      chance = (((1000 + value + skill_value) / 100) * ((1000 - value + skill_value) / 100) * (advrate / 100) * 10);
      chance *= (advrate / 100);

      if (chance > 950) { chance = 950; }
      else if (chance < 200) { chance = 200; }

      chance /= 10;

      // Debug code for advance roll
//      tell(filter_array(all_inventory(environment(this_object())), (: wizardp($1) :)), this_object()->short() + " advance roll for " + skill + ": Is " + roll + " (" + (skill_value * 10) + ") less than " + to_int(ceil(chance)) + "?\n");
//      tell(filter_array(all_inventory(environment(this_object())), (: wizardp($1) :)), this_object()->short() + " skill points for " + skill + ": Is " + my_skill[1] + " >= " + get_skill_point_minimum(advrate) + "?\n");

      if (((roll < ceil(chance)) && (my_skill[1] >= get_skill_point_minimum(advrate))) || (my_skill[1] >= advrate))
      {
         // Advance
         my_skill[0] += 1;
         my_skill[1] = 0;

         tell(this_object(), "%^SKILL_IMPROVE%^You feel better at " + skill_data[0] + "." + (my_skill[0] < 1000 ? "  You are now " + (my_skill[0] % 100) + "% towards Rank " + ((my_skill[0] / 100) + 1) + "." : "") + "%^RESET%^\n");

         if (!(my_skill[0] % 100))
         {
            tell(this_object(), "%^SKILL_IMPROVE%^You have acheived Rank " +  (my_skill[0] / 100) + " in " + skill_data[0] + ".%^RESET%^\n");
         }
      }

      skills[skill] = my_skill;
   }
}

//:FUNCTION test_skill
// Test whether this users' skill succeeds against a given opposing skill
// level.  Returns 1 for success of this user.
int test_skill(string skill, int adjustment)
{
   int roll = random(1000);
   int array my_skill = skills[skill];
   int skill_value;
   int destination_value;
   int stat_bonus = get_stat_bonus(skill);
   float stat_weight = get_stat_weight(skill);

/*
   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to use test_skill on  " + this_object()->short() + ".\n");
   }
*/

   if (sizeof(my_skill) != 2)
   {
      my_skill = ({ 0, 0 });
   }

   skill_value = my_skill[0] + call_hooks("all_skill_bonus", HOOK_SUM) + call_hooks(skill + "_skill_bonus", HOOK_SUM);

//   tell(this_object(), skill + " - bonus: " + stat_bonus + " weight: " + to_int(stat_weight));
   destination_value = stat_bonus / stat_weight * (stat_weight + skill_value + adjustment);

   if (destination_value > 950) { destination_value = 950; }
   else if (destination_value < 50) { destination_value = 50; }

   // Debug code for skillrolls
//   tell(filter_array(all_inventory(environment(this_object())), (: wizardp($1) :)), this_object()->short() + " skill roll for " + skill + ": Is " + destination_value + " more than " + roll + "?\n");

   // semi-hack.. return 1 if roll == 0, 1 in 1000 chance of success
   if (roll == 0) { return 1; }

   if (skill_value < 1000)
   {
      if (destination_value > roll)
      {
         my_skill[1] += 1;
      }
      else
      {
         int evaluation = query_skill_evaluation();

         if (evaluation < 50)
         {
            my_skill[1] += 2;
         }
         else if (evaluation < 75)
         {
            my_skill[1] += 1 + random(2);
         }
         else
         {
            my_skill[1] += random(2);
         }
      }

      skills[skill] = my_skill;

      learn_skill(skill, (stat_bonus / stat_weight * adjustment));
   }

   return (destination_value > roll);
}

//:FUNCTION query_skill_evaluation
//Returns the player's overall evaluation (0 to 100 percent) of their skill point total.
//This evaluation corresponds to how they are doing with respect to the maximum possible skill level.
int query_skill_evaluation()
{
   int total = 0;

   foreach (string skill in keys(skills))
   {
      int array my_skill = skills[skill];

      total += my_skill[0];
   }

   return sizeof(skills) ? to_int(floor(total / (10 * sizeof(skills)))) : 0;
}

void add_learned_skill(string skill)
{
   if (member_array(skill, learned_skills) == -1)
   {
      learned_skills += ({ skill });
   }
}

void remove_learned_skill(string skill)
{
   if (member_array(skill, learned_skills) > -1)
   {
      learned_skills -= ({ skill });
   }
}

int has_learned_skill(string skill)
{
   if (member_array(skill, learned_skills) > -1)
   {
      return 1;
   }

   return 0;
}

string array query_learned_skills()
{
   return sort_array(learned_skills, 1);
}

void add_blocked_skill(string skill)
{
   if (member_array(skill, blocked_skills) == -1)
   {
      blocked_skills += ({ skill });
   }
}

void remove_blocked_skill(string skill)
{
   if (member_array(skill, blocked_skills) > -1)
   {
      blocked_skills -= ({ skill });
   }
}

int has_blocked_skill(string skill)
{
   if (member_array(skill, blocked_skills) > -1)
   {
      return 1;
   }

   return 0;
}

string array query_blocked_skills()
{
   return sort_array(blocked_skills, 1);
}

int get_skill_point_minimum(int adv_rate)
{
   float min = adv_rate;

   switch (query_int())
   {
      case 0..9: min *= 1.00; break;
      case 10..14: min *= 0.99; break;
      case 15..19: min *= 0.98; break;
      case 20..24: min *= 0.97; break;
      case 25..29: min *= 0.96; break;
      case 30..34: min *= 0.95; break;
      case 35..39: min *= 0.94; break;
      case 40..44: min *= 0.92; break;
      case 45..49: min *= 0.90; break;
      case 50..54: min *= 0.88; break;
      case 55..59: min *= 0.86; break;
      case 60..64: min *= 0.84; break;
      case 65..69: min *= 0.82; break;
      case 70..74: min *= 0.79; break;
      case 75..79: min *= 0.76; break;
      case 80..84: min *= 0.73; break;
      case 85..89: min *= 0.70; break;
      case 90..94: min *= 0.67; break;
      case 95..99: min *= 0.64; break;
      case 100..999999: min *= 0.60; break;
   }

   return to_int(ceil(min));
}