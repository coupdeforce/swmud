// Last edited by deforce on 12-23-2007
#include <classes.h>

inherit CLASS_SKILL;

int get_stat_bonus(string skill);
int query_skill_evaluation();

private mapping skills = ([ ]);

class skill set_skill(string skill, int skill_points, int training_points)
{
   class skill cs = skills[skill];

   if (member_array(skill, SKILL_D->query_skills()) == -1)
   {
      error("illegal skill; cannot set new skill value for " + skill + ".\n");
   }

   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set " + this_object()->short() + "'s skill in " + skill + " to " + skill_points + ".\n");
   }

   if (!cs)
   {
      cs = skills[skill] = new(class skill, skill_points : skill_points, training_points : training_points);
   }
   else
   {
      if (skill_points < 1)
      {
         map_delete(skills, skill);
      }
      else
      {
         cs->skill_points = skill_points;
         cs->training_points = training_points;
      }
   }

   return cs;
}

void remove_skill(string skill)
{
   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to remove " + this_object()->short() + "'s skill in " + skill + ".\n");
   }

   if (skills[skill])
   {
      map_delete(skills, skill);
   }
}

void reset_skills()
{
   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to reset " + this_object()->short() + "'s skills.\n");
   }

   skills = ([ ]);
}

mapping get_skills()
{
   return skills;
}

class skill get_skill(string skill)
{
   return skills[skill];
}

//:FUNCTION learn_skill
// Add some number of skill points to the given skill, propogating skill
// values up through the parent skills.  Training points are also assigned
// as appropriate.
void learn_skill(string skill, int value)
{
   class skill my_skill;
   int skill_value;
   int advrate;
   mixed skill_data;
   int roll;
   float chance;

   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to use learn_skill on  " + this_object()->short() + ".\n");
   }

   skill_data = SKILL_D->query_skill(skill);

   if (!skill_data)
   {
      error("No skill data for " + skill + ".\n");
   }

   my_skill = skills[skill];

   if (!my_skill)
   {
      skills[skill] = new(class skill, skill_points : 0, training_points : 0);
      my_skill = skills[skill];
   }

   skill_value = my_skill->skill_points;

   if (skill_value < 1000)
   {
      advrate = skill_data[1];

      roll = random(skill_value * 10);
      chance = (((1000 + value + skill_value) / 100) * ((1000 - value + skill_value) / 100) * (advrate / 100) * 10);
      chance *= (advrate / 100);

      if (chance > 950) { chance = 950; }
      else if (chance < 200) { chance = 200; }

      chance /= 10;

      // Debug code for advance roll
      tell(filter_array(all_inventory(environment(this_object())), (: wizardp($1) :)), this_object()->short() + " advance roll for " + skill + ": Is " + roll + " (" + (skill_value * 10) + ") less than " + to_int(ceil(chance)) + "?\n");

      if ((roll < ceil(chance)) || (my_skill->training_points >= advrate))
      {
         // Advance
         my_skill->skill_points += 1;
         my_skill->training_points = 0;

         if (skills[skill] % 100)
         {
            tell(this_object(), "%^SKILL_IMPROVE%^You notice improvement in " + skill_data[0] + ".%^RESET%^\n");
         }
         else
         {
            tell(this_object(), "%^SKILL_IMPROVE%^You have acheived Rank " +  (skills[skill] / 100) + " in " + skill_data[0] + ".%^RESET%^\n");
         }
      }
   }
}

//:FUNCTION test_skill
// Test whether this users' skill succeeds against a given opposing skill
// level.  Returns 1 for success of this user.
int test_skill(string skill, int adjustment)
{
   int roll = random(1000);
   class skill my_skill = skills[skill];
   int skill_value;
   int destination_value;
   int stat_bonus = get_stat_bonus(skill);

   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to use test_skill on  " + this_object()->short() + ".\n");
   }

   destination_value = skill_value + stat_bonus + adjustment;

   if (destination_value > 950) { destination_value = 950; }
   else if (destination_value < 10) { destination_value = 10; }

   // Debug code for skillrolls
   tell(filter_array(all_inventory(environment(this_object())), (: wizardp($1) :)), this_object()->short() + " skill roll for " + skill + ": Is " + destination_value + " more than " + roll + "?\n");

   // semi-hack.. return 1 if roll == 0, 1 in 1000 chance of success
   if (roll == 0) { return 1; }

   if (skill_value < 1000)
   {
      if (destination_value > roll)
      {
         my_skill->training_points += 1;
      }
      else
      {
         int evaluation = query_skill_evaluation();

         if (evaluation < 50)
         {
            my_skill->training_points += 2;
         }
         else if (evaluation < 75)
         {
            my_skill->training_points += 1;
         }
      }

      learn_skill(skill, stat_bonus + adjustment);
   }

   return (destination_value > roll);
}

//:FUNCTION query_evaluation
//Returns the player's overall evaluation (0 to 100 percent) of their skill point total.
//This evaluation corresponds to how they are doing with respect to the maximum possible skill level.
int query_skill_evaluation()
{
   int total = 0;

   foreach (string skill in keys(skills))
   {
      class skill my_skill = skills[skill];

      total += my_skill->skill_points;
   }

   return floor(total / (1000 * sizeof(skills)));
}