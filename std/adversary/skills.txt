// Last edited by deforce on 11-15-2007
#include <classes.h>

inherit CLASS_SKILL;

#define MAX_SKILL_VALUE 1000

private mapping skills = ([ ]);
private int skill_delay = 0;
private mapping skill_delays = ([ ]);

int set_skill(string skill, int skill_points)
{
   if (skill_points < 1)
   {
      map_delete(skills, skill);
   }
   else
   {
      skills[skill] = skill_points;
   }

   return 1;
}

int get_stat_bonus(string skill)
{
   int bonus; // starts at 0
   int player_stat;
   int stat_weight;
   mixed skill_data;

   skill_data = SKILL_D->query_skill(skill);

   if (!skill_data)
   {
      error("can't find skill " + skill);
      return 0;
   }

   // Strength
   stat_weight = skill_data[2];
   player_stat = this_body()->query_str();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Constitution
   stat_weight = skill_data[3];
   player_stat = this_body()->query_con();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Agility
   stat_weight = skill_data[4];
   player_stat = this_body()->query_agi();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Dexterity
   stat_weight = skill_data[5];
   player_stat = this_body()->query_dex();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Perception
   stat_weight = skill_data[6];
   player_stat = this_body()->query_per();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Intelligence
   stat_weight = skill_data[7];
   player_stat = this_body()->query_int();
   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Charisma
   stat_weight = skill_data[8];
   player_stat = this_body()->query_cha();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Luck
   stat_weight = skill_data[9];
   player_stat = this_body()->query_luc();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Force
   stat_weight = skill_data[10];
   player_stat = this_body()->query_for();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   return bonus;
}

mapping get_skills()
{
   return skills;
}

int query_skill(string skill)
{
   return skills[skill];
}

//:FUNCTION learn_skill
// Attempts to learn a skill
void learn_skill(string skill, int value)
{
   int my_skill;
   int advrate;
   mixed skill_data;
   int roll;

   skill_data = SKILL_D->query_skill(skill);

   if (!skill_data)
   {
      // error
      write("No skill data.\n");
      skill_data = ({ "unknown", 1, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
      //return;
   }

   my_skill = skills[skill];

   if (my_skill < 1000)
   {
      // random 1 through skill advancement rate.
      advrate = skill_data[1];

      roll = random(10000);
      // write("DEBUG: adjusting roll by " + (my_skill / 100) + ".\n");
      roll += my_skill / (100 - value);

      // write("DEBUG: Learn Roll " + roll + " out of " + advrate + ".\n");
      if (roll < advrate)
      {
         // yay, advance.
         skills[skill] += 1;
         tell(this_object(), "%^SKILL_IMPROVE%^You notice improvement in " + skill_data[0] + ".%^RESET%^\n");
      }
   }
}

//:FUNCTION test_skill
// Test whether this users' skill succeeds against a given opposing skill
// level.  Returns 1 for success of this user.
int test_skill(string skill, int adjustment)
{
   int roll = random(1000);
   int skill_value = skills[skill];
   int destination_value;
   int stat_bonus = get_stat_bonus(skill);

   if (skill_value < 1000) { learn_skill(skill, stat_bonus); }

   destination_value = skill_value + stat_bonus + adjustment;

   if (destination_value > 950) { destination_value = 950; }

   if (destination_value < 10) { destination_value = 10; }

   // Debug code for skillrolls
   tell(filter_array(all_inventory(environment(this_object())), (: wizardp($1) :)), this_object()->short() + " skill roll for " + skill + ": Is " + destination_valie + " more than " + roll + "?\n");

   // semi-hack.. return 1 if roll == 0, 1 in 1000 chance of success
   if (roll == 0) { return 1; }

   return (destination_value > roll);
}

//:FUNCTION query_evaluation
//Returns the player's overall evaluation (0 to 100 percent) of their skill
//level.  This evaluation corresponds to how they are doing with respect
//to the maximum possible skill level.
int query_evaluation()
{
   return 0;
}

//:FUNCTION add_skill_delay
// Adds a specificed skill delay in seconds
void add_skill_delay(int delay)
{
   skill_delay = time() + delay;
}

//:FUNCTION has_skill_delay
// Returns 0 if the player can use skills again, the remaing time if not
int has_skill_delay()
{
   if (time() < skill_delay)
   {
      return skill_delay - time();
   }

   skill_delay = 0;

   return 0;
}

//:FUNCTION query_skill_delays
// Returns a mapping of any special skill delays
mapping query_skill_delays()
{
   foreach (string skill in keys(skill_delays))
   {
      if (skill_delays[skill] < time())
      {
         map_delete(skill_delays, skill);
      }
   }

   return skill_delays;
}

//:FUNCTION add_special_skill_delay
// Adds a specificed skill delay in seconds to the specified skill
void add_special_skill_delay(string skill, int delay)
{
   skill_delays[skill] = time() + delay;
}

//:FUNCTION has_special_skill_delay
// Returns 0 if the player can use the specified skill again, the remaing time if not
int has_special_skill_delay(string skill)
{
   if (skill_delays[skill] && (time() < skill_delays[skill]))
   {
      return skill_delays[skill] - time();
   }

   map_delete(skill_delays, skill);

   return 0;
}