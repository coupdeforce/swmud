// Last edited by deforce on 12-22-2007
#include <classes.h>

inherit CLASS_SKILL;

#define MAX_SKILL_VALUE 1000

private mapping skills = ([ ]);
private int skill_delay = 0;
private mapping skill_delays = ([ ]);

int set_skill(string skill, int skill_points)
{
   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set " + this_object()->short() + "'s skill in " + skill + " to " + skill_points + ".\n");
   }

   if (skill_points < 1)
   {
      map_delete(skills, skill);
   }
   else
   {
      skills[skill] = skill_points;
   }

   return 1;
}

int get_stat_bonus(string skill)
{
   int bonus; // starts at 0
   int player_stat;
   int stat_weight;
   mixed skill_data;

   skill_data = SKILL_D->query_skill(skill);

   if (!skill_data)
   {
      error("can't find skill " + skill);
      return 0;
   }

   // Strength
   stat_weight = skill_data[2];
   player_stat = this_body()->query_str();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Constitution
   stat_weight = skill_data[3];
   player_stat = this_body()->query_con();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Agility
   stat_weight = skill_data[4];
   player_stat = this_body()->query_agi();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Dexterity
   stat_weight = skill_data[5];
   player_stat = this_body()->query_dex();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Perception
   stat_weight = skill_data[6];
   player_stat = this_body()->query_per();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Intelligence
   stat_weight = skill_data[7];
   player_stat = this_body()->query_int();
   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Charisma
   stat_weight = skill_data[8];
   player_stat = this_body()->query_cha();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Luck
   stat_weight = skill_data[9];
   player_stat = this_body()->query_luc();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   // Force
   stat_weight = skill_data[10];
   player_stat = this_body()->query_for();

   if (stat_weight != 0)
   {
      player_stat *= stat_weight;
      player_stat /= 100;

      bonus += player_stat;
   }

   return bonus;
}

mapping get_skills()
{
   return skills;
}

int query_skill(string skill)
{
   return skills[skill];
}

//:FUNCTION learn_skill
// Attempts to learn a skill
void learn_skill(string skill, int value)
{
   int skill_value;
   int advrate;
   mixed skill_data;
   int roll;
   float chance;

   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to use learn_skill on  " + this_object()->short() + ".\n");
   }

   skill_data = SKILL_D->query_skill(skill);

   if (!skill_data)
   {
      // error
      write("No skill data.\n");
      skill_data = ({ "unknown", 1, 100, 0, 0, 0, 0, 0, 0, 0, 0, 0 });
      //return;
   }

   skill_value = skills[skill];

   if (skill_value < 1000)
   {
      advrate = skill_data[1];

      roll = random(skill_value * 10);
      chance = (((1000 + value + skill_value) / 100) * ((1000 - value + skill_value) / 100) * (advrate / 100) * 10);
      chance *= (advrate / 100);

      if (chance > 950) { chance = 950; }
      else if (chance < 200) { chance = 200; }

      chance /= 10;

      // Debug code for advance roll
      tell(filter_array(all_inventory(environment(this_object())), (: wizardp($1) :)), this_object()->short() + " advance roll for " + skill + ": Is " + roll + " (" + (skill_value * 10) + ") less than " + to_int(ceil(chance)) + "?\n");

      if (roll < ceil(chance))
      {
         // Advance
         skills[skill] += 1;

         if (skills[skill] % 100)
         {
            tell(this_object(), "%^SKILL_IMPROVE%^You notice improvement in " + skill_data[0] + ".%^RESET%^\n");
         }
         else
         {
            tell(this_object(), "%^SKILL_IMPROVE%^You have acheived Rank " +  (skills[skill] / 100) + " in " + skill_data[0] + ".%^RESET%^\n");
         }
      }
   }
}

//:FUNCTION test_skill
// Test whether this users' skill succeeds against a given opposing skill
// level.  Returns 1 for success of this user.
int test_skill(string skill, int adjustment)
{
   int roll = random(1000);
   int skill_value = skills[skill];
   int destination_value;
   int stat_bonus = get_stat_bonus(skill);

   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to use test_skill on  " + this_object()->short() + ".\n");
   }

   if (skill_value < 1000) { learn_skill(skill, stat_bonus + adjustment); }

   destination_value = skill_value + stat_bonus + adjustment;

   if (destination_value > 950) { destination_value = 950; }
   else if (destination_value < 10) { destination_value = 10; }

   // Debug code for skillrolls
   tell(filter_array(all_inventory(environment(this_object())), (: wizardp($1) :)), this_object()->short() + " skill roll for " + skill + ": Is " + destination_value + " more than " + roll + "?\n");

   // semi-hack.. return 1 if roll == 0, 1 in 1000 chance of success
   if (roll == 0) { return 1; }

   return (destination_value > roll);
}

//:FUNCTION query_evaluation
//Returns the player's overall evaluation (0 to 100 percent) of their skill
//level.  This evaluation corresponds to how they are doing with respect
//to the maximum possible skill level.
int query_evaluation()
{
   return 0;
}

//:FUNCTION add_skill_delay
// Adds a specificed skill delay in seconds
void add_skill_delay(int delay)
{
   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to add skill delay of " + delay + " to " + this_object()->short() + ".\n");
   }

   skill_delay = time() + delay;
}

//:FUNCTION has_skill_delay
// Returns 0 if the player can use skills again, the remaing time if not
int has_skill_delay()
{
   if (time() < skill_delay)
   {
      return skill_delay - time();
   }

   skill_delay = 0;

   return 0;
}

//:FUNCTION query_skill_delays
// Returns a mapping of any special skill delays
mapping query_skill_delays()
{
   foreach (string skill in keys(skill_delays))
   {
      if (skill_delays[skill] < time())
      {
         map_delete(skill_delays, skill);
      }
   }

   return skill_delays;
}

//:FUNCTION add_special_skill_delay
// Adds a specificed skill delay in seconds to the specified skill
void add_special_skill_delay(string skill, int delay)
{
   if (this_body() && (this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to add special skill delay of " + delay + " to " + this_object()->short() + " for " + skill + ".\n");
   }

   skill_delays[skill] = time() + delay;
}

//:FUNCTION has_special_skill_delay
// Returns 0 if the player can use the specified skill again, the remaing time if not
int has_special_skill_delay(string skill)
{
   if (skill_delays[skill] && (time() < skill_delays[skill]))
   {
      return skill_delays[skill] - time();
   }

   map_delete(skill_delays, skill);

   return 0;
}