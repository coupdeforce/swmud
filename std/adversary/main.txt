// Last edited by deforce on 10-12-2009
#include <hooks.h>

mixed call_hooks(string, int);
string query_random_limb();
object query_weapons();
object query_target();
object get_target();
void add_event(object target, object weapon, mixed target_extra, mixed data, object attacker);
int badly_wounded();
int panic();
varargs void stop_fight(object);
int check_condition(int);
int query_stunned();
void simple_action(string);
void my_action(string);
int query_damage_bonus();
int query_ghost();
int query_agi();
int test_skill(string skill);
void target_is_asleep();
void handle_events();
int is_body();
int has_skill_delay();
void perform_combat_action();
int start_fight(object who);
varargs int check_wimpy(object target);

private nosave int speed_bonus = 0;

void take_a_swing(object target)
{
   if (check_wimpy() || this_body()->query_stunned())
   {
      return;
   }

//   speed_bonus = random(((this_body()->query_agi() * 2) / 5) + 21) > 55 ? 1 : 0;
   speed_bonus = (query_agi() * (20 + call_hooks("combat_speed_bonus", HOOK_SUM))) > random(5000) ? 1 : 0;

   foreach (object weapon in query_weapons())
   {
      for (int count = 0; count < (weapon->query_weapon_speed() + speed_bonus); count++)
      {
         if (query_ghost() || !(target = get_target()))
         {
            stop_fight();
            return;
         }

         if (!test_skill(weapon->query_skill_used()) && (random(251) > (weapon->query_to_hit_bonus() + call_hooks("to_hit_bonus", HOOK_SUM))))
         {
            add_event(target, weapon, query_random_limb(), "miss", this_object());
         }
         else
         {
            add_event(target, weapon, query_random_limb(), random(weapon->query_weapon_class() + query_damage_bonus()) + 1, this_object());

            handle_events();
         }

         start_fight(target);
      }
   }

   if (!this_body()->is_body() && !this_body()->has_skill_delay())
   {
      this_body()->perform_combat_action();
   }
}

int check_wimpy(object target)
{
   string array room_exits = ({ });

   if (!target) { target = this_object(); }

   room_exits = environment(target)->query_exit_directions(wizardp(target));

   if (!sizeof(room_exits)) { return; }

   if (target->query_health() < target->query_wimpy_threshold())
   {
      string direction = target->query_wimpy_dir();
      object previous_target = query_target();

      if (direction != "out")
      {
         if (member_array(direction, environment(target)->query_exit_directions(0)) > -1)
         {
            target->do_game_command("go " + direction);
            target->query_target();
            previous_target->query_target();

            return 1;
         }
      }

      target->do_game_command("go " + choice(room_exits));
      target->query_target();
      previous_target->query_target();

      return 1;
   }

   return 0;
}

void attack()
{
   object target;
   mixed tmp;

   // check whether we are capable of attacking
   if (tmp = check_condition(1))
   {
      if (tmp[<1] == '\n') { write(tmp); }
      else { my_action(tmp + " and cannot attack."); }

      return;
   }

   target = get_target();

   // Any reason to continue the carnage?
   if (query_ghost() || !target)
   {
      stop_fight();
      return;
   }

   if (target->query_asleep())
   {
      // Our target is unconcious. We get to have our way with them *evil grin*
      target_is_asleep();
      return;
   }

   take_a_swing(target);
   handle_events();
}