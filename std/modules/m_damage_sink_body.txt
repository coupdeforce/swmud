// Last edited by deforce on 10-10-2008
// Adversary's natural armor
#include <hooks.h>

inherit CLASS_EVENT_INFO;

mixed call_hooks(string, int);

private nosave int armor_bonus;
private mapping body_resistances = ([]);
private mapping body_weaknesses = ([]);

//:FUNCTION query_armor_class
// Query the current armor class of an object.  Higher is better.
int query_armor_class()
{
   object this_ob = this_object();
   int level = this_ob->query_primary_level();

//   return to_int(floor(((level / 5.0) + (level / 10.0) + (level / 20.0) + (level / 25.0) + (level / 50.0)) * (this_ob->query_con() / 100.0)));
   return to_int(floor((((level / 10.0) * 3) + ((level / 25.0) * 2) + (level / 50.0)) * (this_ob->query_con() / 100)));
}

//:FUNCTION query_max_armor_class
// Query the maximum armor class of an object.  Higher is better.
int query_max_armor_class()
{
   return query_armor_class();
}

//:FUNCTION query_jedi_armor_class
// Query a Jedi's armor class, based on jedi_defense
int query_jedi_armor_class()
{
   object this_ob = this_object();
   int rank = to_int(floor(this_ob->query_skill("jedi_defense") / 100.0));
   int jedi_alignment = this_ob->query_jedi_alignment();
   int jedi_armor = jedi_alignment > 0 ? ceil(this_ob->query_guild_level("jedi") / 3.5) : floor(this_ob->query_guild_level("jedi") / 5.0);

   return to_int(jedi_armor + (jedi_alignment > 0 ? ceil(jedi_armor * rank * 0.1) : floor(jedi_armor * rank * 0.05)));
}

//:FUNCTION query_durability
// Query the current durability of an object.  Higher is better.
int query_durability()
{
   return 100;
}

//:FUNCTION query_max_durability
// Query the current maximum durability of an object.  Higher is better.
int query_max_durability()
{
   return 100;
}

//:FUNCTION query_chance_to_be_damaged
// Query the probability for this to be damaged
int query_chance_to_be_damaged()
{
   return 0;
}

//:FUNCTION set_armor_bonus
// Set an overall modifier of armor class on the object.  The bonus
// does not get saved, so should only be used for temporary bonuses. (i.e. buffs)
void set_armor_bonus(int bonus)
{
   armor_bonus = bonus;
}

void add_armor_bonus(int value)
{
   armor_bonus += value;
}

int query_armor_bonus()
{
   return armor_bonus;
}

class event_info sink_modify_event(class event_info evt)
{
   int damage_before_sink = evt->data[1];
   int force_shield = call_hooks("force_shield", HOOK_SUM);
   int effective_armor_class = query_armor_class();

   if (stringp(evt->data)) { return evt; }

   if ((force_shield > 0) && (member_array(evt->data[0], ({ "combat-unarmed", "combat-blade", "combat-blunt" })) > -1))
   {
      int damage_reduction = (evt->data[1] * force_shield) / 100;

      if (damage_reduction < 1) { damage_reduction = 1; }

      evt->data[1] -= damage_reduction;

      tell(evt->target, "(Your Force shield adjusted damage from " + damage_before_sink + " to " + evt->data[1] + ")\n");
   }

   if (member_array(evt->data[0], keys(body_weaknesses)) != -1)
   {
      evt->data[1] += random(body_weaknesses[evt->data[0]] + 1);
   }
   else if (member_array(evt->data[0], keys(body_resistances)) != -1)
   {
      evt->data[1] -= random(body_resistances[evt->data[0]] + 1);
   }

   if (effective_armor_class > evt->data[1])
   {
      effective_armor_class = evt->data[1];
   }

   evt->data[1] -= (random(effective_armor_class) + armor_bonus + 1);

   if (evt->target->query_guild_level("jedi") && evt->target->has_learned_skill("jedi defense"))
   {
      int jedi_alignment = evt->target->query_jedi_alignment();

      evt->data[1] -= (random(evt->target->query_jedi_armor_class()) + 1);

      evt->target->test_skill("jedi_defense", jedi_alignment * (jedi_alignment < 0 ? 20 : 10));
   }

   if (evt->data[1] < 0) { evt->data[1] = 0; }

//   if (wizardp(evt->target) && (damage_before_sink > 0) && (damage_before_sink > evt->data[1]))
   if ((damage_before_sink > 0) && (damage_before_sink > evt->data[1]))
   {
      tell(evt->target, "(Your natural armor adjusted damage from " + damage_before_sink + " to " + evt->data[1] + ")\n");
   }

   return evt;
}

//:FUNCTION is_armor
// Returns 1 if the object is a damage_sink.
int is_armor()
{
   return 1;
}

//:FUNCTION set_resist
// Specifies that for damage of type 'type', the armor class should be increased by 'amt'
void set_resist(string type, int amt)
{
   body_resistances[type] = amt;
}

//:FUNCTION set_resistances
// Set all the resistances an armor possesses.
void set_resistances(mapping x)
{
   body_resistances = x;
}

//:FUNCTION set_weakness
// Specifies that for damage of type 'type', the armor class should be decreased by 'amt'
void set_weakness(string type, int amt)
{
   body_weaknesses[type] = amt;
}

void set_weaknesses(mapping weak)
{
   body_weaknesses = weak;
}