// Updated by deforce on 03-02-2007
/*
** m_wearable.c
**
** Mixed in to create a wearable item.  The client should also
** mix in M_GETTABLE.
**
** 07-Sep-94. Created. Rust/Belboz.
** 12-Nov-94. Updated for "modules" approach. Deathblade.
** 970421, Deathblade: switched to flags to pick up attributes
** 25 March, 1998: Iizuka made major changes to support the new adversary
                   code.
*/

#include <flags.h>

void hook_state(string, mixed, int);
string worn_extra_short();
int test_flag(int);
void assign_flag(int, int);
void add_save(string array);
void clear_flag(int);

private string wearmsg = "$N $vwear a $o.";
private nosave string slot;
private nosave string array also_covering = ({ });

void mudlib_setup()
{
   add_save(({ "persist_flags" }));
}

mixed ob_state()
{
   if (!test_flag(F_WORN)) { return 0; }

   return slot;
}

int valid_wear() // Return 1 if they can wear this.
{
   return 1;
}

int valid_remove() // Return 1 if they can remove this.
{
   return 1;
}

//:FUNCTION set_wearmsg
//Set the message used when an object is worn.
void set_wearmsg(string message)
{
   wearmsg = message;
}

//:FUNCTION query_wearmsg
//Return the message given when an object is used.
string query_wearmsg()
{
   return wearmsg;
}

//:FUNCTION set_slot
//Set the bodyslot that the wearable object takes up.
void set_slot(string which)
{
   slot = which;
}

//FUNCTION query_slot
//Return the bodyslot the wearable object takes up.
string query_slot()
{
   return slot;
}

string array also_covers()
{
   return also_covering;
}

void set_also_covers(string array slots...)
{
   also_covering = slots;
}

string worn_attributes()
{
   string array all = ({ slot });

   if (also_covers()) { all += also_covers(); }

   if (sizeof(all) > 1)
   {
      string array limbs = ({ });

      if (member_array("head", all) != -1) { limbs += ({ "head" }); }

      if (member_array("torso", all) != -1) { limbs += ({ "torso" }); }

      if ((member_array("left arm", all) != -1) && (member_array("right arm", all) != -1))
      {
         limbs += ({ "arms" });
      }

      if ((member_array("left hand", all) != -1) && (member_array("right hand", all) != -1))
      {
         limbs += ({ "hands" });
      }

      if ((member_array("left leg", all) != -1) && (member_array("right leg", all) != -1))
      {
         limbs += ({ "legs" });
      }

      if ((member_array("left foot", all) != -1) && (member_array("right foot", all) != -1))
      {
         limbs += ({ "feet" });
      }

      if (sizeof(limbs) > 1)
      {
         return " worn over " + implode(limbs[0..(sizeof(limbs) - 2)], ", ") +
            " and " + limbs[sizeof(limbs) - 1];
      }
      else
      {
         return " worn over " + limbs[0];
      }
   }
   else { return " worn over " + all[0]; }
}

string damaged_attributes()
{
   if (!test_flag(F_BROKEN)) { return " (damaged)"; }

   return "";
}

string broken_attributes()
{
   return " (broken)";
}

//:FUNCTION set_worn
//set_worn(1) causes an object to become worn.  set_worn(0) removes it.
void set_worn(int g)
{
   assign_flag(F_WORN, g);
//   hook_state("prevent_drop", "You'll have to take it off first.\n", g);
}

void remove()
{
   object env = environment();

   if (!slot || !env) { return 0; }

   if (sizeof(also_covering))
   {
      foreach (string other_slot in also_covering)
      {
         env->remove_item(this_object(), other_slot);
      }
   }

   env->remove_item(this_object(), slot);
   set_worn(0);
}

void do_wear()
{
   if (!slot) { return; }

   if (test_flag(F_BROKEN))
   {
      environment()->simple_action("$N $vdiscover that the $o is too broken to wear.", this_object());

      return;
   }

   if (!environment()->wear_item(this_object(), slot))
   {
      if (test_flag(F_WORN))
      {
         environment()->simple_action("$N $vdiscover $ns $vare wearing the $o.", this_object());
      }
      else
      {
         environment()->simple_action("$N $vdiscover $ns cannot wear the $o.", this_object());
      }

      return;
   }

   set_worn(1);
   environment()->simple_action(query_wearmsg(), this_object());
}

void do_remove()
{
   if (!slot) { return 0; }

   if (test_flag(F_WORN))
   {
      if (sizeof(also_covering))
      {
//         this_body()->simple_action("$N $vfind out that the $o covers more than one slot.", this_object());

         foreach (string other_slot in also_covering)
         {
//            this_body()->simple_action("$N $vlook at the $o covering $p " + other_slot + ".", this_object());
            environment()->remove_item(this_object(), other_slot);
         }
      }

      environment()->remove_item(this_object(), slot);
      set_worn(0);

      this_body()->simple_action("$N $vremove $p $o.", this_object());
   }
}

mixed direct_wear_obj()
{
   object who = owner(this_object());

   if (who != this_body()) { return 0; }

   foreach (string body_slot in (also_covering + ({ slot })))
   {
      if (sizeof(this_body()->query_armors(body_slot)) > 1)
      {
         write("You're already wearing something that covers that area.\n");

         return 0;
      }
   }

   if (test_flag(F_WORN))
   {
      write("You're already wearing that.\n");

      return 0;
   }

   return 1;
}

mixed direct_remove_obj()
{
   object who = owner(this_object());

   if (who != this_body()) { return 0; }

   if (environment() != this_body() || !test_flag(F_WORN))
   {
      write("You're not wearing that.\n");

      return 0;
   }

   return 1;
}