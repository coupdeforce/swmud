// Last edited by deforce on 12-22-2007
// Created by Deathblade 08-13-1995

#include <classes.h>
#include <hooks.h>

mixed call_hooks(string, int);

private int stat_str; // Strength
private int stat_con; // Constitution
private int stat_agi; // Agility
private int stat_dex; // Dexterity
private int stat_per; // Perception
private int stat_int; // Intelligence
private int stat_cha; // Charisma
private int stat_luc; // Luck
private int stat_for; // Force

private int cur_str;
private int cur_con;
private int cur_agi;
private int cur_dex;
private int cur_per;
private int cur_int;
private int cur_cha;
private int cur_luc;
private int cur_for;

private int points_remaining; // Used for character creation

void refresh_stats();

nomask int query_points_remaining()
{
   return points_remaining;
}

nomask void set_points_remaining(int n)
{
   if ((this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set creation points remaining for " + this_object()->short() + " to " + n + ".\n");
   }

   points_remaining = n;
}

// query_xxx_pure() returns the "pure" unadulterated statistic.
// query_xxx() returns the statistic adjusted for all temporary effects
nomask int query_str_pure() { return stat_str; }
nomask int query_con_pure() { return stat_con; }
nomask int query_agi_pure() { return stat_agi; }
nomask int query_dex_pure() { return stat_dex; }
nomask int query_per_pure() { return stat_per; }
nomask int query_int_pure() { return stat_int; }
nomask int query_cha_pure() { return stat_cha; }
nomask int query_luc_pure() { return stat_luc; }
nomask int query_for_pure() { return stat_for; }

nomask int query_str() { return cur_str; }
nomask int query_con() { return cur_con; }
nomask int query_agi() { return cur_agi; }
nomask int query_dex() { return cur_dex; }
nomask int query_per() { return cur_per; }
nomask int query_int() { return cur_int; }
nomask int query_cha() { return cur_cha; }
nomask int query_luc() { return cur_luc; }
nomask int query_for() { return cur_for; }

nomask void set_str(int n)
{
   if ((this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set strength for " + this_object()->short() + " to " + n + ".\n");
   }

   stat_str = n;
   refresh_stats();
}

nomask void set_con(int n)
{
   if ((this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set constitution for " + this_object()->short() + " to " + n + ".\n");
   }

   stat_con = n;
   refresh_stats();
}

nomask void set_agi(int n)
{
   if ((this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set agility for " + this_object()->short() + " to " + n + ".\n");
   }

   stat_agi = n;
   refresh_stats();
}

nomask void set_dex(int n)
{
   if ((this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set dexterity for " + this_object()->short() + " to " + n + ".\n");
   }

   stat_dex = n;
   refresh_stats();
}

nomask void set_per(int n)
{
   if ((this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set perception for " + this_object()->short() + " to " + n + ".\n");
   }

   stat_per = n;
   refresh_stats();
}

nomask void set_int(int n)
{
   if ((this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set intelligence for " + this_object()->short() + " to " + n + ".\n");
   }

   stat_int = n;
   refresh_stats();
}

nomask void set_cha(int n)
{
   if ((this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set charisma for " + this_object()->short() + " to " + n + ".\n");
   }

   stat_cha = n;
   refresh_stats();
}

nomask void set_luc(int n)
{
   if ((this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set luck for " + this_object()->short() + " to " + n + ".\n");
   }

   stat_luc = n;
   refresh_stats();
}

nomask void set_for(int n)
{
   if ((this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to set force for " + this_object()->short() + " to " + n + ".\n");
   }

   stat_for = n;
   refresh_stats();
}

//:FUNCTION refresh_stats
//refresh_stats() recalculates all the stats and requery's all the bonuses.
//Combat calls this once a round.  If you are using stats in a non-combat
//setting, you might want to call this first.
void refresh_stats()
{
//:HOOK str_bonus
//Used to modify strength
//:HOOK con_bonus
//Used to modify constitution
//:HOOK agi_bonus
//Used to modify agility
//:HOOK dex_bonus
//Used to modify dexterity
//:HOOK per_bonus
//Used to modify perception
//:HOOK int_bonus
//Used to modify intelligence
//:HOOK cha_bonus
//Used to modify charisma
//:HOOK luc_bonus
//Used to modify luck
//:HOOK for_bonus
//Used to modify force

   int adj_str, adj_con, adj_agi, adj_dex, adj_per, adj_int, adj_cha, adj_luc, adj_for;
   int limb_health;

   cur_str = stat_str + (adj_str = call_hooks("str_bonus", HOOK_SUM));
   cur_con = stat_con + (adj_con = call_hooks("con_bonus", HOOK_SUM));
   cur_agi = stat_agi + (adj_agi = call_hooks("agi_bonus", HOOK_SUM));
   cur_dex = stat_dex + (adj_dex = call_hooks("dex_bonus", HOOK_SUM));
   cur_per = stat_per + (adj_per = call_hooks("per_bonus", HOOK_SUM));
   cur_int = stat_int + (adj_int = call_hooks("int_bonus", HOOK_SUM));
   cur_cha = stat_cha + (adj_cha = call_hooks("cha_bonus", HOOK_SUM));
   cur_luc = stat_luc + (adj_luc = call_hooks("luc_bonus", HOOK_SUM));
   cur_for = stat_for + (adj_for = call_hooks("for_bonus", HOOK_SUM));

//   this_object()->set_max_capacity(cur_str * 3);
   this_object()->set_max_capacity(((cur_str + 100) * (1.25 * (cur_str / 100.0))) + 50);
   this_object()->set_weapon_class(cur_str ? to_int(cur_str / 3.3) : 9);
   this_object()->set_armor_class(cur_con ? to_int(cur_con / 4) : 10);
   this_object()->set_to_hit_bonus((cur_agi / 2) - 35);  // Unarmed to-hit penalty or bonus

   // Recalculate limb health
   limb_health = (this_object()->query_max_health() * (((cur_con / 3) + (cur_con * (cur_con / 300))) / (133.3 - (cur_con / 3)))) + (this_object()->query_max_health() / 3);

   foreach (string limb in this_object()->query_limbs())
   {
      this_object()->set_max_limb_health(limb, limb_health);
   }
}

// This is later modified by race
nomask void init_stats()
{
   if ((this_body() != this_object()) && (wizardp(this_body()->query_userid()) < 3))
   {
      error("Invalid attempt to reset " + this_object()->short() + "'s stats to racial minimums.\n");
   }

   stat_str = this_object()->query_race_str_min();
   stat_con = this_object()->query_race_con_min();
   stat_agi = this_object()->query_race_agi_min();
   stat_dex = this_object()->query_race_dex_min();
   stat_per = this_object()->query_race_per_min();
   stat_int = this_object()->query_race_int_min();
   stat_cha = this_object()->query_race_cha_min();
   stat_luc = this_object()->query_race_luc_min();
   stat_for = this_object()->query_race_for_min();

   refresh_stats();
}