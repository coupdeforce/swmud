// Last edited by deforce on 02-17-2010
inherit OBJ;
inherit M_DAMAGE_SOURCE;
inherit M_WIELDABLE;
inherit M_VALUABLE;
inherit M_GETTABLE;
inherit M_MESSAGES;

void mudlib_setup()
{
   object::mudlib_setup();
   m_wieldable::mudlib_setup();
   add_id("weapon");
   add_save( ({ "persist_flags" }) );
}

mixed ob_state()
{
   return object::ob_state() + "/" + !!m_wieldable::ob_state();
}

void remove()
{
   object::remove();
   m_wieldable::unwield();
}

int indirect_kill_liv_with_obj()
{
   return 1;
}

mixed direct_holster_obj_to_obj() { return 1; }
mixed direct_unholster_obj_from_obj() { return 1; }

class event_info source_modify_event(class event_info evt)
{
   if (stringp(evt->data)) { return evt; }

   if (evt->data[1] > 0)
   {
      object wielder = query_wielded_by();
      string skill = this_object()->query_skill_used();
      int rank = (wielder->query_skill(skill) / 100);
      int weapon_class = this_object()->query_weapon_class();
      int damage_before_adj = evt->data[1];
      int cap = floor(weapon_class * ((10.0 + (rank * 9.0)) / 100.0));

      if (evt->data[1] > cap)
      {
         evt->data[1] = (cap > 0 ? cap : 1);

         tell(wielder, sprintf("Damage adjusted from %d to %d.\n", damage_before_adj, evt->data[1]));
      }
   }

   return evt;
}